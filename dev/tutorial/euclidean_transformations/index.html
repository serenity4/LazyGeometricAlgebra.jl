<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Euclidean transformations · SymbolicGA.jl</title><meta name="title" content="Euclidean transformations · SymbolicGA.jl"/><meta property="og:title" content="Euclidean transformations · SymbolicGA.jl"/><meta property="twitter:title" content="Euclidean transformations · SymbolicGA.jl"/><meta name="description" content="Documentation for SymbolicGA.jl."/><meta property="og:description" content="Documentation for SymbolicGA.jl."/><meta property="twitter:description" content="Documentation for SymbolicGA.jl."/><meta property="og:url" content="https://serenity4.github.io/SymbolicGA.jl/stable/tutorial/euclidean_transformations/"/><meta property="twitter:url" content="https://serenity4.github.io/SymbolicGA.jl/stable/tutorial/euclidean_transformations/"/><link rel="canonical" href="https://serenity4.github.io/SymbolicGA.jl/stable/tutorial/euclidean_transformations/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="https://plausible.io/js/script.js" data-domain="serenity4.github.io" defer></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SymbolicGA.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../glossary/">Glossary</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li class="is-active"><a class="tocitem" href>Euclidean transformations</a><ul class="internal"><li><a class="tocitem" href="#Transformations-around-the-origin"><span>Transformations around the origin</span></a></li><li><a class="tocitem" href="#Transformations-around-arbitrary-axes"><span>Transformations around arbitrary axes</span></a></li></ul></li><li><a class="tocitem" href="../integration/">Integration with your own types</a></li></ul></li><li><span class="tocitem">Explanation</span><ul><li><a class="tocitem" href="../../explanation/geometric_algebra/">Geometric Algebra</a></li><li><a class="tocitem" href="../../explanation/design/">Design</a></li></ul></li><li><span class="tocitem">How to</span><ul><li><a class="tocitem" href="../../howto/integration/">Use macros with custom types</a></li><li><a class="tocitem" href="../../howto/spaces/">Create user-defined geometric spaces</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference/symbols/">Symbols &amp; operators</a></li><li><a class="tocitem" href="../../reference/api/">API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Euclidean transformations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Euclidean transformations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/serenity4/SymbolicGA.jl/blob/main/docs/src/tutorial/euclidean_transformations.jl#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Euclidean-transformations"><a class="docs-heading-anchor" href="#Euclidean-transformations">Euclidean transformations</a><a id="Euclidean-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Euclidean-transformations" title="Permalink"></a></h1><p>Geometric algebra being well suited for the representation of orthogonal transformations, we will go through different ways one can apply <a href="https://en.wikipedia.org/wiki/Rigid_transformation">Euclidean transformations</a>, using various geometric spaces of interest. Euclidean transformations are those which preserve the Euclidean distance between two points. They include reflections, rotations and translations expressed in an Euclidean space, as well as any composition of these. Orthogonal transformations only include reflections and rotations, but translations may be represented as orthogonal transformations within special non-Euclidean geometric spaces (quick hint: a translation may be viewed as a rotation following a circle of infinite radius).</p><h2 id="Transformations-around-the-origin"><a class="docs-heading-anchor" href="#Transformations-around-the-origin">Transformations around the origin</a><a id="Transformations-around-the-origin-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations-around-the-origin" title="Permalink"></a></h2><p>The simplest transformations are defined around the origin. In contrast, take for example rotations around an axis that does not contain the origin, whose expression requires translations. Note that the translational part there is a trick to get back to the origin, apply the rotation, and revert the translation.</p><p>We will take <span>$\mathbb{R}^3$</span> as our base space of interest, and define a geometric space over it:</p><pre><code class="language-julia hljs">using SymbolicGA</code></pre><p>Generates a <code>@r3</code> macro.</p><pre><code class="language-julia hljs">@geometric_space r3 &quot;+++&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">@r3 (macro with 2 methods)</code></pre><p>Note that we are not defining <span>$\mathbb{R}^3$</span> itself, but rather <span>$\mathcal{G}(\mathbb{R}^3)$</span>, the geometric space around <span>$\mathbb{R}^3$</span>.</p><p>This macro will allow us to use geometric algebra expressions, that will be processed and return Julia code that can be evaluated which implements the operations we aim to perform.</p><p>We will not attempt to express a rotation as an action around an axis vector. For example, in 2D space, we will have to construct a rotation without reference to a third axis, which would only exist in 3D space. We will construct our rotation by specifying the plane in which the action should be carried out.</p><p>Such a plane may be parametrized by two non-colinear vectors, say <code>a</code> and <code>b</code>. We form such an object using the outer product, which has the effect of joining vectors <code>a</code> and <code>b</code> into a geometric entity which contains them both:</p><pre><code class="language-julia hljs">a = (2.0, 0.0, 0.0)
b = (-2.0, 1.0, 0.0)
Π = @r3 a::1 ∧ b::1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Bivector{Float64, 3, 3}(2.0, 0.0, 0.0)</code></pre><p>You will have noticed that neither <code>a</code> or <code>b</code> are unit vectors, and <code>Π</code> is not a unit plane. <code>a</code> and <code>b</code> are not orthogonal either. That is not a problem; we will handle that later, for now all we need is the plane in which they are contained, and therefore any choice of non-colinear vectors <code>a</code> and <code>b</code> will work.</p><p>Next, we compute an object <code>Ω</code> which describes a rotation along a plane <code>Π</code> with angle <code>α</code>; <code>Π</code> needs to be a unit plane, so we add a unitization (&quot;renormalization&quot;) step to enforce that.</p><pre><code class="language-julia hljs">α = π / 15
Ω = @r3 exp(-(0.5α)::0 ⟑ unitize(Π::2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(KVector{0, Float64, 3, 1}(0.9945218953682733), Bivector{Float64, 3, 3}(-0.10452846326765346, 0.0, -0.0))</code></pre><p><code>Ω</code> is a particular kind of object: a versor. Versors are geometric products of invertible vectors, and the exponentiation of a bivector is one way to obtain such a versor. Seeing that we obtain a scalar and a bivector, you could wonder: why not define <code>Ω = @r3 a::1 ⟑ b::1</code>? This is because <code>Ω</code> would then describe a very specific rotation: a rotation in the plane formed by <code>a</code> and <code>b</code> - so far so good -, but of twice the angle between <code>a</code> and <code>b</code> multiplied by <code>norm(a) * norm(b)</code>. If we want to apply a rotation with an arbitrary angle, we essentially have to find and join two unit vectors in the plane of rotation such that they form half the desired angle of rotation between them, <code>α / 2</code>. This is what the exponential form above parametrizes: for any <code>α</code>, the resulting <code>Ω</code> is the versor corresponding to two such vectors (in the plane of rotation, with an angle of <code>α / 2</code>), describing a rotation in that plane by an angle <code>α</code>.</p><p>Say we want to rotate</p><pre><code class="language-julia hljs">x = (3.0, 4.0, 5.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(3.0, 4.0, 5.0)</code></pre><p>How should we apply <code>Ω</code> to <code>x</code>? The operation we seek to carry out is an orthogonal transformation, using <code>Ω</code>. In geometric algebra, orthogonal transformations are obtained by a specific operation on versors, termed the <em>versor product</em> (informally named the sandwich product). The versor product on <code>x</code> by <code>Ω</code> is defined as <code>Ω ⟑ x ⟑ inverse(Ω)</code>, which is defined by default with the <code>x &lt;&lt; Ω</code> operator.</p><pre><code class="language-julia hljs">x′ = @r3 x::1 &lt;&lt; Ω::(0, 2)
@assert x′ ≈ @r3 Ω::(0, 2) ⟑ x::1 ⟑ inverse(Ω::(0, 2))


x′</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">KVector{1, Float64, 3, 3}(2.10279603893038, 4.536325475388501, 5.0)</code></pre><p>The inverse rotation may be applied using the inverse of our versor Ω:</p><pre><code class="language-julia hljs">x′′ = @r3 x′::1 &lt;&lt; inv(Ω::(0, 2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">KVector{1, Float64, 3, 3}(3.000000000000001, 4.000000000000001, 5.0)</code></pre><p>We did get <code>x</code> back! But numbers being a bit hard to visualize, we prepared a small animation to see the rotation in action using Makie:</p><p><video src="../../plots/color_animation.mp4" controls="true" title><a href="../../plots/color_animation.mp4"></a></video></p><p>Non-unit vectors <code>a</code> and <code>b</code> are represented in green and cyan. The bivector formed by <code>a</code> and <code>b</code> is represented as a purple semi-transparent parallelogram, with its dual - the normal of the plane - represented as a solid purple line.</p><h2 id="Transformations-around-arbitrary-axes"><a class="docs-heading-anchor" href="#Transformations-around-arbitrary-axes">Transformations around arbitrary axes</a><a id="Transformations-around-arbitrary-axes-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations-around-arbitrary-axes" title="Permalink"></a></h2><p>We just performed a rotation around the origin. How can we get rotations around arbitrary points in space?</p><p>Although planes arised naturally to describe 3D rotations around the origin, things change a bit when rotating around arbitrary points. It is still valid to define rotations within specific planes, <em>but that plane must contain the object being rotated</em>. As we were working with geometries defined around the origin, it was always the case. In fact, the specificity of standard vector spaces such as <span>$\mathcal{G}(\mathbb{R}^2)$</span> or <span>$\mathcal{G}(\mathbb{R}^3)$</span> or their &quot;vanilla&quot; geometric spaces such as <span>$\mathcal{G}(\mathbb{R}^2)$</span> or <span>$\mathcal{G}(\mathbb{R}^3)$</span> is that geometric entities always contain the origin. A point is always represented by a vector pointing from the origin to a location, and this prevents vectors from being represented as entities invariant by affine transformations (which include translations). If you translate a vector in <span>$\mathbb{R}^3$</span>, only the target location of the vector is translated, but the origin remains the same. For geometric spaces, the situation is the same - they build from the base vector space, and therefore inherit their limitations. For example, bivectors are formed of vectors pointing from the origin, and therefore represent planes parametrized by three points: the point of origin, and the two vector target locations.</p><p>This limitation in terms of representation does not prevent translations from being defined, but they do not integrate well with the mathematical model; if you translate the whole space, geometric operations do not represent the same thing before and after the translation. Just like vectors, a translated bivector represents a different plane, and not one that is a translation of the original. The &quot;mathematical&quot; way of saying all this, is that Euclidean space (and Euclidean geometry - geometries represented using Euclidean space) is not invariant with respect to translation.</p><p>Coming from another angle, you could ask: &quot;Why, in the first place, do we special-case an origin - aren&#39;t all points in 3D space considered the same?&quot;. Well, an Euclidean space is one in which angles are defined and points are parametrized by numbers - coordinates -, enabling various measurements; it is the space as seen from a specific location, the origin. No wonder that translating it results in a different space.</p><p>We therefore need another space. The spaces that are invariant with respect to translations (and rotations) are called affine spaces. In these spaces, points and vectors are different from each other; adding two points is undefined, while vectors can be added and points translated by vectors. Affine spaces are the intrinsic space we generally compute in - but because we need to represent points with numbers, we identify an origin to allow for a coordinate system, and carry operations in Euclidean space. Forgetting about the origin and staying purely in affine space is tricky; even if we can mathematically describe elements in affine spaces, without an origin we cannot describe them with numerical values.</p><p>How can we get out of this situation? We need to find another space, which has an origin so we can numerically represent objects with coordinates, but which also contains an affine space as a subspace. The classical setting is to use a four-dimensional Euclidean space, and use a three-dimensional hyperplane located at <code>w = 1</code>; in other terms, Euclidean 3D space is embedded within the four-dimensional Euclidean space with the map <span>$(x, y, z) \rightarrow (x, y, z, 1)$</span>. It works well in removing the 3D origin as a special point - it happens to be <code>(0, 0, 0, 1)</code>, but is treated just like any other point on that hyperplane from the persepctive of a four-dimensional space. We will go slightly further however, and trade a tiny bit of intuition by defining a geometric space with signature <span>$(3, 0, 1)$</span> instead of <span>$(4, 0, 0)$</span> to obtain more elegant and simpler formulas that describe translations and rotations. A walkthrough of the geometric spaces over <span>$\mathbb{R}^3$</span> (2D projective space) and <span>$\mathbb{R}^4$</span> (3D projective space) is provided in the books <em>Geometric Algebra for Computer Science - An Object-Oriented Approach to Geometry</em> and <em>Aspects of Geometric Algebra in Euclidean, Projective and Conformal Space</em>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting started</a><a class="docs-footer-nextpage" href="../integration/">Integration with your own types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Monday 27 November 2023 12:29">Monday 27 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
