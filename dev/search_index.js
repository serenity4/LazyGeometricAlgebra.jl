var documenterSearchIndex = {"docs":
[{"location":"howto/spaces/","page":"Create user-defined geometric spaces","title":"Create user-defined geometric spaces","text":"EditURL = \"spaces.jl\"","category":"page"},{"location":"howto/spaces/#Creating-user-defined-geometric-spaces","page":"Create user-defined geometric spaces","title":"Creating user-defined geometric spaces","text":"","category":"section"},{"location":"howto/spaces/#Create-a-geometric-space-with-default-definitions","page":"Create user-defined geometric spaces","title":"Create a geometric space with default definitions","text":"","category":"section"},{"location":"howto/spaces/","page":"Create user-defined geometric spaces","title":"Create user-defined geometric spaces","text":"using SymbolicGA\n\n@geometric_space weird_space (3, 4, 5)","category":"page"},{"location":"howto/spaces/","page":"Create user-defined geometric spaces","title":"Create user-defined geometric spaces","text":"x = rand(12); y = rand(12)\n@weird_space x::1 ⟑ dual(y::1)","category":"page"},{"location":"howto/spaces/#Create-a-geometric-space-with-extra-definitions.","page":"Create user-defined geometric spaces","title":"Create a geometric space with extra definitions.","text":"","category":"section"},{"location":"howto/spaces/","page":"Create user-defined geometric spaces","title":"Create user-defined geometric spaces","text":"@geometric_space extra_space 3 quote\n  >>(x, y) = versor_product(y, x)\n  *(x, y) = geometric_product(y, x)\n  I = 1.0::e123\nend","category":"page"},{"location":"howto/spaces/","page":"Create user-defined geometric spaces","title":"Create user-defined geometric spaces","text":"x = rand(3); y = rand(3)\n@extra_space begin\n  yᵈ = y::1 * I\n  yᵈ >> x::1\nend","category":"page"},{"location":"howto/spaces/#Create-a-geometric-space-with-non-default-bindings.","page":"Create user-defined geometric spaces","title":"Create a geometric space with non-default bindings.","text":"","category":"section"},{"location":"howto/spaces/","page":"Create user-defined geometric spaces","title":"Create user-defined geometric spaces","text":"bindings = Bindings(refs = Dict(:* => :geometric_product))\n@geometric_space no_defaults 3 bindings","category":"page"},{"location":"howto/spaces/","page":"Create user-defined geometric spaces","title":"Create user-defined geometric spaces","text":"x = rand(3); y = rand(3)\n@no_defaults x::1 * y::1","category":"page"},{"location":"howto/spaces/","page":"Create user-defined geometric spaces","title":"Create user-defined geometric spaces","text":"Note that you will always have access to the built-in functions.","category":"page"},{"location":"howto/spaces/","page":"Create user-defined geometric spaces","title":"Create user-defined geometric spaces","text":"","category":"page"},{"location":"howto/spaces/","page":"Create user-defined geometric spaces","title":"Create user-defined geometric spaces","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/integration/","page":"Integration with your own types","title":"Integration with your own types","text":"EditURL = \"integration.jl\"","category":"page"},{"location":"tutorial/integration/#Integration-with-user-defined-types","page":"Integration with your own types","title":"Integration with user-defined types","text":"","category":"section"},{"location":"tutorial/integration/","page":"Integration with your own types","title":"Integration with your own types","text":"If you want to use values of a custom type in expressions for @ga (or any specific geometric space generated by @geometric_space), you are totally free to do so. By default, component extraction relies on 1-based indexing via SymbolicGA.getcomponent, which should be fine most of the time. If that won't work for you for any reason, you can still extend this method with your own types. The choices are therefore the following:","category":"page"},{"location":"tutorial/integration/","page":"Integration with your own types","title":"Integration with your own types","text":"Extend Base.getindex(::MyType, ::Int)\nExtend SymbolicGA.getcomponent(::MyType, ::Int)","category":"page"},{"location":"tutorial/integration/","page":"Integration with your own types","title":"Integration with your own types","text":"using SymbolicGA\n\nstruct MyType{T}\n  components::Dict{Symbol, T}\nend\nindex_to_symbol(i) = (:x, :y, :z)[i]\n\nSymbolicGA.getcomponent(x::MyType, i) = x.components[index_to_symbol(i)]\n\nx = MyType(Dict(:x => 1.5, :y => 2.0, :z => 3.0))\ny = MyType(Dict(:x => 1.2, :y => -1.4, :z => 0.1))\n@ga 3 dual(x::1 ∧ y::1)","category":"page"},{"location":"tutorial/integration/","page":"Integration with your own types","title":"Integration with your own types","text":"Note that we still got a KVector out by default; if you want, you may provide MyType as output, but you also need to define how to reconstruct a type given a tuple of components. By default, SymbolicGA.construct calls the provided type constructor on the tuple of components. You may therefore either:","category":"page"},{"location":"tutorial/integration/","page":"Integration with your own types","title":"Integration with your own types","text":"Define a MyType(::Tuple) constructor\nExtend SymbolicGA.construct(::Type{MyType}, ::Tuple)","category":"page"},{"location":"tutorial/integration/","page":"Integration with your own types","title":"Integration with your own types","text":"SymbolicGA.construct(T::Type{<:MyType}, components::Tuple) = T(Dict((:x, :y, :z) .=> components))\n\n@ga 3 MyType dual(x::1 ∧ y::1)","category":"page"},{"location":"tutorial/integration/","page":"Integration with your own types","title":"Integration with your own types","text":"Of course, you can also omit the return type and operate with a KVector. In fact, that is recommended especially if you don't know what kind of object you'll end up with. For example, would you know what dual((x::1 ⟑ y::1) ⋅ y::1) + exp(x::1 ∧ y::1) returns? Well, let's see:","category":"page"},{"location":"tutorial/integration/","page":"Integration with your own types","title":"Integration with your own types","text":"@ga 3 dual((x::1 ⟑ y::1) ⋅ y::1) + exp(x::1 ∧ y::1)","category":"page"},{"location":"tutorial/integration/","page":"Integration with your own types","title":"Integration with your own types","text":"Looks like we got a scalar and a bivector! We could manipulate this KVector around, which is a mere allocation-free wrapper over a tuple, but if you already know what type of data structure you want to put your data into, you may find it more convenient to specify it when calling the macro.","category":"page"},{"location":"tutorial/integration/","page":"Integration with your own types","title":"Integration with your own types","text":"","category":"page"},{"location":"tutorial/integration/","page":"Integration with your own types","title":"Integration with your own types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"EditURL = \"euclidean_transformations.jl\"","category":"page"},{"location":"tutorial/euclidean_transformations/#Euclidean-transformations","page":"Euclidean transformations","title":"Euclidean transformations","text":"","category":"section"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"Geometric algebra being well suited for the representation of orthogonal transformations, we will go through different ways one can apply Euclidean transformations, using various geometric spaces of interest. Euclidean transformations are those which preserve the Euclidean distance between two points. They include reflections, rotations and translations expressed in an Euclidean space, as well as any composition of these. Orthogonal transformations only include reflections and rotations, but translations may be represented as orthogonal transformations within special non-Euclidean geometric spaces (quick hint: a translation may be viewed as a rotation following a circle of infinite radius).","category":"page"},{"location":"tutorial/euclidean_transformations/#Transformations-around-the-origin","page":"Euclidean transformations","title":"Transformations around the origin","text":"","category":"section"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"The simplest transformations are defined around the origin. In contrast, take for example rotations around an axis that does not contain the origin, whose expression requires translations. Note that the translational part there is a trick to get back to the origin, apply the rotation, and revert the translation.","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"We will take mathbbR^3 as our base space of interest, and define a geometric space over it:","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"using SymbolicGA","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"Generates a @r3 macro.","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"@geometric_space r3 \"+++\"","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"Note that we are not defining mathbbR^3 itself, but rather mathcalG(mathbbR^3), the geometric space around mathbbR^3.","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"This macro will allow us to use geometric algebra expressions, that will be processed and return Julia code that can be evaluated which implements the operations we aim to perform.","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"We will not attempt to express a rotation as an action around an axis vector. For example, in 2D space, we will have to construct a rotation without reference to a third axis, which would only exist in 3D space. We will construct our rotation by specifying the plane in which the action should be carried out.","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"Such a plane may be parametrized by two non-colinear vectors, say a and b. We form such an object using the outer product, which has the effect of joining vectors a and b into a geometric entity which contains them both:","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"a = (2.0, 0.0, 0.0)\nb = (-2.0, 1.0, 0.0)\nΠ = @r3 a::1 ∧ b::1","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"You will have noticed that neither a or b are unit vectors, and Π is not a unit plane. a and b are not orthogonal either. That is not a problem; we will handle that later, for now all we need is the plane in which they are contained, and therefore any choice of non-colinear vectors a and b will work.","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"Next, we compute an object Ω which describes a rotation along a plane Π with angle α; Π needs to be a unit plane, so we add a unitization (\"renormalization\") step to enforce that.","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"α = π / 15\nΩ = @r3 exp(-(0.5α)::0 ⟑ unitize(Π::2))","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"Ω is a particular kind of object: a versor. Versors are geometric products of invertible vectors, and the exponentiation of a bivector is one way to obtain such a versor. Seeing that we obtain a scalar and a bivector, you could wonder: why not define Ω = @r3 a::1 ⟑ b::1? This is because Ω would then describe a very specific rotation: a rotation in the plane formed by a and b - so far so good -, but of twice the angle between a and b multiplied by norm(a) * norm(b). If we want to apply a rotation with an arbitrary angle, we essentially have to find and join two unit vectors in the plane of rotation such that they form half the desired angle of rotation between them, α / 2. This is what the exponential form above parametrizes: for any α, the resulting Ω is the versor corresponding to two such vectors (in the plane of rotation, with an angle of α / 2), describing a rotation in that plane by an angle α.","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"Say we want to rotate","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"x = (3.0, 4.0, 5.0)","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"How should we apply Ω to x? The operation we seek to carry out is an orthogonal transformation, using Ω. In geometric algebra, orthogonal transformations are obtained by a specific operation on versors, termed the versor product (informally named the sandwich product). The versor product on x by Ω is defined as Ω ⟑ x ⟑ inverse(Ω), which is defined by default with the x << Ω operator.","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"x′ = @r3 x::1 << Ω::(0, 2)\n@assert x′ ≈ @r3 Ω::(0, 2) ⟑ x::1 ⟑ inverse(Ω::(0, 2))\n\nusing LinearAlgebra: norm # hide\n@assert norm(x) ≈ norm(x′) # hide\n\nx′","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"The inverse rotation may be applied using the inverse of our versor Ω:","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"@assert KVector{1,3}(x) ≈ @r3 x′::1 << inv(Ω::(0, 2)) # hide\nx′′ = @r3 x′::1 << inv(Ω::(0, 2))","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"We did get x back! But numbers being a bit hard to visualize, we prepared a small animation to see the rotation in action using Makie:","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"(Image: )","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"Non-unit vectors a and b are represented in green and cyan. The bivector formed by a and b is represented as a purple semi-transparent parallelogram, with its dual - the normal of the plane - represented as a solid purple line.","category":"page"},{"location":"tutorial/euclidean_transformations/#Transformations-around-arbitrary-axes","page":"Euclidean transformations","title":"Transformations around arbitrary axes","text":"","category":"section"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"We just performed a rotation around the origin. How can we get rotations around arbitrary points in space?","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"Although planes arised naturally to describe 3D rotations around the origin, things change a bit when rotating around arbitrary points. It is still valid to define rotations within specific planes, but that plane must contain the object being rotated. As we were working with geometries defined around the origin, it was always the case. In fact, the specificity of standard vector spaces such as mathcalG(mathbbR^2) or mathcalG(mathbbR^3) or their \"vanilla\" geometric spaces such as mathcalG(mathbbR^2) or mathcalG(mathbbR^3) is that geometric entities always contain the origin. A point is always represented by a vector pointing from the origin to a location, and this prevents vectors from being represented as entities invariant by affine transformations (which include translations). If you translate a vector in mathbbR^3, only the target location of the vector is translated, but the origin remains the same. For geometric spaces, the situation is the same - they build from the base vector space, and therefore inherit their limitations. For example, bivectors are formed of vectors pointing from the origin, and therefore represent planes parametrized by three points: the point of origin, and the two vector target locations.","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"This limitation in terms of representation does not prevent translations from being defined, but they do not integrate well with the mathematical model; if you translate the whole space, geometric operations do not represent the same thing before and after the translation. Just like vectors, a translated bivector represents a different plane, and not one that is a translation of the original. The \"mathematical\" way of saying all this, is that Euclidean space (and Euclidean geometry - geometries represented using Euclidean space) is not invariant with respect to translation.","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"Coming from another angle, you could ask: \"Why, in the first place, do we special-case an origin - aren't all points in 3D space considered the same?\". Well, an Euclidean space is one in which angles are defined and points are parametrized by numbers - coordinates -, enabling various measurements; it is the space as seen from a specific location, the origin. No wonder that translating it results in a different space.","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"We therefore need another space. The spaces that are invariant with respect to translations (and rotations) are called affine spaces. In these spaces, points and vectors are different from each other; adding two points is undefined, while vectors can be added and points translated by vectors. Affine spaces are the intrinsic space we generally compute in - but because we need to represent points with numbers, we identify an origin to allow for a coordinate system, and carry operations in Euclidean space. Forgetting about the origin and staying purely in affine space is tricky; even if we can mathematically describe elements in affine spaces, without an origin we cannot describe them with numerical values.","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"How can we get out of this situation? We need to find another space, which has an origin so we can numerically represent objects with coordinates, but which also contains an affine space as a subspace. The classical setting is to use a four-dimensional Euclidean space, and use a three-dimensional hyperplane located at w = 1; in other terms, Euclidean 3D space is embedded within the four-dimensional Euclidean space with the map (x y z) rightarrow (x y z 1). It works well in removing the 3D origin as a special point - it happens to be (0, 0, 0, 1), but is treated just like any other point on that hyperplane from the persepctive of a four-dimensional space. We will go slightly further however, and trade a tiny bit of intuition by defining a geometric space with signature (3 0 1) instead of (4 0 0) to obtain more elegant and simpler formulas that describe translations and rotations. A walkthrough of the geometric spaces over mathbbR^3 (2D projective space) and mathbbR^4 (3D projective space) is provided in the books Geometric Algebra for Computer Science - An Object-Oriented Approach to Geometry and Aspects of Geometric Algebra in Euclidean, Projective and Conformal Space.","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"","category":"page"},{"location":"tutorial/euclidean_transformations/","page":"Euclidean transformations","title":"Euclidean transformations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"glossary/#Glossary","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Geometric algebra: Mathematical framework based around the geometric product, relying on an exterior algebra to construct entities of geometric significance.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Geometric space: Mathematical space defined with objects and a geometric product satisfying the axioms of geometric algebra, using a metric defined by a custom signature. Usually described as an algebra in most presentations of geometric algebra, e.g. PGA or CGA, even though different \"algebras\" are still algebraically very similar, as they use the same rules - just a different base space and metric.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Signature: Parameter of a geometric space determining the scalar value of the square of its basis vectors under the geometric product.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"EditURL = \"getting_started.jl\"","category":"page"},{"location":"tutorial/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"SymbolicGA is a library build upon the metaprogramming capabilities of the language to express and simplify geometric algebra expressions at compile-time. This brings the potential of optimality to its implementation, but may feel a bit odd to use compared to most Julia libraries. Additionally, there were unforeseen advantages to keeping geometric algebra operators as pure notation in a symbolic realm: it allows naming things as you like without worrying about choosing names for Julia functions or structures that satisfy everyone (because, unfortunately, consensus on notation for geometric algebra is pretty far away at the moment).","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"This package defines two high-level symbols:","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"A single macro, @ga, which allows you to setup your own geometric algebra context and evaluate arbitrary geometric algebra expressions.\nA single structure, KVector, which simply wraps components with additional information regarding what type of geometric entity it is, and the dimension of the space inside which it was produced.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"The KVector structure is generally useful to understand what you are getting out of @ga and is produced by default. However, the idea of this package is to be able to directly use and generate data from and into your own data structures, provided that a certain interface is fulfilled. For example, if you are designing a computational geometry library, you can define your own types such as Point, Line, Circle etc and use them in @ga. No need to juggle with types from another library! After all, geometric algebra defines semantically meaningful transformations, but cares little about how the data has been abstracted over or how it is stored in memory.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"A few more advanced features will allow you to seamlessly integrate geometric algebra within your own codebase:","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"Utilities for code generation, including codegen_expression, Bindings, default_bindings will be useful to build macros that automate\nInterface functions SymbolicGA.getcomponent and SymbolicGA.construct to use your own types within generated expressions, in case the defaults based on indexing and constructors do not fit with the design of your data structures.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"We will explain how these features work separately and together, to unlock the expression of geometric algebra within Julia in a performant and non-intrusive way.","category":"page"},{"location":"tutorial/getting_started/#Using-[@ga](@ref)","page":"Getting started","title":"Using @ga","text":"","category":"section"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"The simplest way to define your own geometric space and carry operations on it is to use the @ga macro. For example, to construct the geometric space over mathbbR^2, noted mathcalG(mathbbR^2), you first specify a signature for this space. Then, you can perform any operations you like, provided that you annotate the type of your values:","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"using SymbolicGA\n\nx = 1.0\ny = 2.0\n@ga 2 x::e1 + y::e2","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"We simply constructed a simple vector within mathcalG(mathbbR^2) by associating scalar components with basis vectors e1 and e2. Most of the time though, unless you desire to construct a geometric entity with sparse components, you will prefer providing vectors as annotated iterables, such as","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"@ga 2 (x, y)::Vector","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"Note that this Vector annotation does not mean Base.Vector; it means a mathematical vector in the geometric space of interest. Now, let us take the geometric product ⟑ (\\wedgedot) of two vectors:","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"a = (x, y)\nb = rand(2)\n\n@ga 2 a::Vector ⟑ b::Vector","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"Here, we obtained a mathematical object composed of both a 0-vector (scalar) and a 2-vector (bivector) part. In mathcalG(mathbbR^2), a bivector has a single component, but with most other spaces bivectors have more; for any embedded space of dimension n, the number of elements for an entity with grade k is binomial(n, k).","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"note: Note\nIf you dislike the use of non-ASCII characters for major operators, you can use standard function names instead of operators, such as geometric_product(x, y) (equivalent to x ⟑ y) (see Table of symbols).","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"What if we wanted only the scalar part or the bivector part? We can project the result into either grade 0 or grade 2, respectively:","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"@ga 2 (a::Vector ⟑ b::Vector)::Scalar","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"@ga 2 (a::Vector ⟑ b::Vector)::Bivector","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"Since it may be a bit tedious to type in these names by hand, when all we really need is to express the grade in these annotations, we can directly use a number on the right-hand side of :: (see Type annotations).","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"@ga 2 (a::1 ⟑ b::1)::0","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"In this particular case, getting the lowest and highest grade component of a geometric product is what defines the inner and outer products, ⋅ (\\cdot) and ∧ (\\wedge). See Table of symbols for a complete list of symbols and operators.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"@ga 2 a::1 ⋅ b::1","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"@ga 2 a::1 ∧ b::1","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"You can tweak the signature of the geometric space to your liking, if you want to use other spaces. For example, we can embed a 2D vector into Minkowski space (used to express flat spacetime, also called \"Space-time algebra\" or STA in works using geometric algebra):","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"c = rand(4)","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"@ga (3, 1) c::1 ⋅ c::1","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"If you are a bit lazy, you may annotate the c once before the expression:","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"@ga (3, 1) begin\n  c::1\n  c ⋅ c\nend","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"These are the very basics, now you know how to evaluate geometric algebra expressions in arbitrary geometric spaces. Feel free to look at other tutorials to learn about meaningful operations to perform!","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"EditURL = \"integration.jl\"","category":"page"},{"location":"howto/integration/#howto-integration","page":"Use macros with custom types","title":"Use your own types in geometric algebra expressions","text":"","category":"section"},{"location":"howto/integration/#Inputs","page":"Use macros with custom types","title":"Inputs","text":"","category":"section"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"If the type you use supports indexing, e.g. Vector, it already works:","category":"page"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"using SymbolicGA\n\nx = rand(3)\ny = rand(3)\n\n@ga 3 x::1 ∧ y::1","category":"page"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"If your type does not support indexing, and you don't want it to, overload SymbolicGA.getcomponent(::T, [i::Int, [j::Int]]):","category":"page"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"struct MyInputType{T}\n  values::Vector{T}\nend\n\nSymbolicGA.getcomponent(x::MyInputType, i::Int) = x.values[i]\n\nx = MyInputType(rand(3))\ny = MyInputType(rand(3))\n\n@ga 3 x::1 ∧ y::1","category":"page"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"For scalars and aggregates of objects with multiple grades, you will need to overload SymbolicGA.getcomponent(::T) and SymbolicGA.getcomponent(::T, j::Int, i::Int) respectively (see SymbolicGA.getcomponent).","category":"page"},{"location":"howto/integration/#Outputs","page":"Use macros with custom types","title":"Outputs","text":"","category":"section"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"If you want to reconstruct a custom type from components, either define a constructor for a single tuple argument, e.g. T(components::Tuple)","category":"page"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"struct MyOutputType{T}\n  values::Vector{T}\nend\n\nMyOutputType(x::Tuple) = MyOutputType(collect(x))\n\nx = rand(3)\ny = rand(3)\n\n@ga 3 MyOutputType dual(x::1 ∧ y::1)","category":"page"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"If you don't want such constructor to be defined, you can overload SymbolicGA.construct(::Type{T}, ::Tuple) directly:","category":"page"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"struct MyOutputType2{T}\n  values::Vector{T}\nend\n\nSymbolicGA.construct(T::Type{<:MyOutputType2}, x::Tuple) = MyOutputType2(collect(x))\n\nx = rand(3)\ny = rand(3)\n\n@ga 3 MyOutputType2 dual(x::1 ∧ y::1)","category":"page"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"Integrations for Vector, Tuple and <:Real have already been defined:","category":"page"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"@ga 3 Tuple dual(x::1 ∧ y::1)","category":"page"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"@ga 3 Vector dual(x::1 ∧ y::1)","category":"page"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"z = rand(3)\n@ga 3 Float16 dual(x::1 ∧ y::1 ∧ z::1)","category":"page"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"","category":"page"},{"location":"howto/integration/","page":"Use macros with custom types","title":"Use macros with custom types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/symbols/#Table-of-symbols","page":"Symbols & operators","title":"Table of symbols","text":"","category":"section"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"These tables list all the functions, operators and constants that are recognized as geometric operations, e.g. in code evaluated as part of a @ga block.","category":"page"},{"location":"reference/symbols/#builtins","page":"Symbols & operators","title":"Built-in functions","text":"","category":"section"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"These functions are always accessible in any context, and cannot be overriden:","category":"page"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"+(a, b, ...)\n-(a)\n-(a, b)\nreverse(a)\nantireverse(a)\nleft_complement(a)\nright_complement(a)\ngeometric_product(a, b, ...)\nexterior_product(a, b, ...)\ninterior_product(a, b)\ncommutator_product(a, b)\ninverse(a)\nexp(a)","category":"page"},{"location":"reference/symbols/#Default-symbols","page":"Symbols & operators","title":"Default symbols","text":"","category":"section"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"Although any operation in geometric algebra may be performed using the built-in functions above, it is useful to have access to shorthands and other operators which build on these primitives. Therefore, default functions and operators are provided, as well as a few aliases and constants.","category":"page"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"These are obtained with default_bindings, and may be tweaked or removed if you choose to reimplement your own macro over @ga using Expression generation utilities.","category":"page"},{"location":"reference/symbols/#Functions","page":"Symbols & operators","title":"Functions","text":"","category":"section"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"These functions define secondary operators that are more or less standard in geometric algebra. Many of these operators were extracted from E. Lengyel's PGA poster.","category":"page"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"Function Definition\nantidivision inverse_dual(division(dual(a), dual(b)))\nantiinverse inverse_dual(inverse(dual(a)))\nantiscalar_product geometric_antiproduct(a, antireverse(a))::e̅\nbulk_left_complement geometric_product(antireverse(a), 𝟙)\nbulk_norm sqrt(interior_product(a, reverse(a)))::e\nbulk_right_complement geometric_product(reverse(a), 𝟙)\nbulk weight_left_complement(bulk_right_complement(a))\ndivision geometric_product(a, inverse(b))\nexterior_antiproduct inverse_dual(exterior_product(dual(a), dual(b)))\ngeometric_antiproduct inverse_dual(geometric_product(dual(a), dual(b)))\ngeometric_norm bulk_norm(a) + weight_norm(a)\ninterior_antiproduct inverse_dual(interior_product(dual(a), dual(b)))\nleft_interior_antiproduct exterior_product(a, right_complement(b))\nleft_interior_product exterior_antiproduct(left_complement(a), b)\nprojected_geometric_norm antidivision(bulk_norm(a), weight_norm(a))\nright_interior_antiproduct exterior_product(left_complement(a), b)\nright_interior_product exterior_antiproduct(a, right_complement(b))\nscalar_product geometric_product(a, reverse(a))::Scalar\nunitize antidivision(a, weight_norm(a))\nversor_product geometric_product(b, a, inverse(b))\nweight_left_complement geometric_antiproduct(𝟏, antireverse(a))\nweight_norm sqrt(interior_antiproduct(a, antireverse(a)))::e̅\nweight_right_complement geometric_antiproduct(𝟏, reverse(a))\nweight bulk_left_complement(weight_right_complement(a))","category":"page"},{"location":"reference/symbols/#Operators","page":"Symbols & operators","title":"Operators","text":"","category":"section"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"Convenient binary operators are defined by default to allow a more compact language to perform geometric operations. Note that there is no agreed-upon convention for these, and that is why we prefer to allow more advanced users to tweak them at will:","category":"page"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"Function Unicode input Expression\na ⟑ b \\wedgedot geometric_product(a, b)\na ⟇ b (Julia 1.10 or higher) \\veedot geometric_antiproduct(a, b)\na ⩒ b \\veeodot geometric_antiproduct(a, b)\na ⋅ b \\cdot interior_product(a, b)\na ● b \\mdlgblkcircle interior_product(a, b)\na ○ b \\bigcirc interior_antiproduct(a, b)\na ⦿ b \\circledbullet scalar_product(a, b)\na ∧ b \\wedge exterior_product(a, b)\na ∨ b \\vee exterior_antiproduct(a, b)\na ⊣ b \\dashv left_interior_product(a, b)\na ⊢ b \\vdash right_interior_product(a, b)\na ⨼ b \\intprod left_interior_antiproduct(a, b)\na ⨽ b \\intprodr right_interior_antiproduct(a, b)\na << b  versor_product(a, b)\na / b  division(a, b)\na'  reverse(a)","category":"page"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"note: Note\nIn many materials about geometric algebra, the geometric product uses the same notation as the standard multiplication operator, * (or even juxtaposition). However, we prefer to use the \\wedgedot symbol ⟑ proposed by E. Lengyel to visually show its relationship with the inner and outer products, ⋅ and ∧, and because it allows the use of an \"anti-\" operator to express the dual operator to the geometric product, the geometric antiproduct ⟇ (\\veedot, available from Julia 1.10). There are also programming-related motivations, as 2x destructures to 2 * x which would rarely want to be considered as \"the geometric product of 2 and x\".","category":"page"},{"location":"reference/symbols/#Aliases","page":"Symbols & operators","title":"Aliases","text":"","category":"section"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"A few aliases are defined, with a short-hand for the inverse and a specific choice of a dual and dual inverse, along with common names for operators we named differently:","category":"page"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"Symbol Alias\ninv inverse\ndual right_complement\ninverse_dual left_complement\nregressive_product exterior_antiproduct\nleft_contraction left_interior_product\nright_contraction right_interior_product","category":"page"},{"location":"reference/symbols/#Constants","page":"Symbols & operators","title":"Constants","text":"","category":"section"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"These constants allow you to complactly express scalar and antiscalar units.","category":"page"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"Symbol Input Expression\n𝟏 \\bfone 1::e\n𝟙 \\bbone 1::e̅","category":"page"},{"location":"reference/symbols/#Type-annotations","page":"Symbols & operators","title":"Type annotations","text":"","category":"section"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"Considering an n-dimensional space, the various ways to annotate a value are as follows:","category":"page"},{"location":"reference/symbols/","page":"Symbols & operators","title":"Symbols & operators","text":"Annotation Alias Grade or basis blade\n::e1  Basis vector e_1 (grade 1)\n::e12 ::e_1_2 Basis blade e_1 wedge e_2 (grade 2)\n::e_11_12  Basis blade e_11 wedge e_12 (grade 2, more than one digit per index)\n::Scalar ::0, ::e 0\n::Vector ::1 1\n::Bivector ::2 2\n::Trivector ::3 3\n::Quadvector ::4 4\n::Antiscalar ::ē n\n::(k, l, ...)  Tuple of multiple elements of grade k, l, ...\n::(k + l + ...)  Concatenation of multiple elements of grade k, l, ...\n::Multivector  Concatenation of all elements with grade 0 to n","category":"page"},{"location":"explanation/geometric_algebra/#Geometric-Algebra","page":"Geometric Algebra","title":"Geometric Algebra","text":"","category":"section"},{"location":"explanation/geometric_algebra/","page":"Geometric Algebra","title":"Geometric Algebra","text":"This section is dedicated to briefly introducing geometric algebra, and provide resources for further information. Note that geometric algebra is a vast topic, drawing from specialized and advanced branches of geometry in mathematics.","category":"page"},{"location":"explanation/geometric_algebra/#Introduction","page":"Geometric Algebra","title":"Introduction","text":"","category":"section"},{"location":"explanation/geometric_algebra/","page":"Geometric Algebra","title":"Geometric Algebra","text":"Geometric algebra is an algebraic framework which allows elegant and efficient expressions of geometric entities and transformations. For example, its projective version over mathbbR^3 compactly expresses intersections between points, lines and planes without introducing coordinates nor equations; the conformal version additionally expresses circles and spheres, and unifies translations and rotations in a single geometric object, again in a coordinate-free manner. For those familiar with quaternions, these are contained in the geometric algebra over the vector space mathbbR^3, and can be better understood intuitively as part of a bigger framework than usually presented. Rotations can furthermore be expressed in the geometric algebra over the vector space mathbbR^2 without having to resort to embedding it within mathbbR^3, as is the case for a treatment of rotations using the standard cross product. This specific algebra over mathbbR^2 contains complex numbers as a subalgebra, in the same way that the geometric algebra over mathbbR^3 contains quaternions as a subalgebra.","category":"page"},{"location":"explanation/geometric_algebra/","page":"Geometric Algebra","title":"Geometric Algebra","text":"The major advantages of such a framework resides in:","category":"page"},{"location":"explanation/geometric_algebra/","page":"Geometric Algebra","title":"Geometric Algebra","text":"Requiring a low symbolic complexity, with clean abstractions that do not require special casings on coordinate systems nor looking up complex formulas to express common geometric operations.\nProviding good intuition about the nature of geometric operations, with clear semantics assigned to many of the operators within geometric algebra and connections to numerous branches of mathematics related to geometry.","category":"page"},{"location":"explanation/geometric_algebra/","page":"Geometric Algebra","title":"Geometric Algebra","text":"The implications to programming are largely tied to the simplicity and consistency over many applications. In certain contexts, it is possible to perform more efficient operations than standard methods by exploiting the sparsity of certain structures; for example, 3D rotations can be expressed by matrices, but with intrinsically fewer degrees of freedom than a general 3x3 matrix. However, the most noticeable improvements reside in lower code complexity, resulting in easier maintenance and understandability of implementations of geometric operations.","category":"page"},{"location":"explanation/geometric_algebra/","page":"Geometric Algebra","title":"Geometric Algebra","text":"Nevertheless, it should be noted that geometric algebra requires a certain mastery before showing its usefulness. In a way, this is a complicated swiss knife which has a steep learning curve and which departs from classic approaches to geometry that one may be more familiar with. Learning about geometric algebra is not an easy task, and is notably recommended for implementers and users of algorithms related to computational geometry and for those that are curious and desiring to gain a deeper insight about the different angles from which geometry can be viewed.","category":"page"},{"location":"explanation/geometric_algebra/","page":"Geometric Algebra","title":"Geometric Algebra","text":"In particular, as an algebraic framework and a highly convenient utility, it very rarely provides new results unknown to other branches of mathematics; but it can easily unlock them to those unused to advanced abstract reasoning, and foster new developments through a unified language and insights that result from its elegance.","category":"page"},{"location":"explanation/geometric_algebra/#Resources","page":"Geometric Algebra","title":"Resources","text":"","category":"section"},{"location":"explanation/geometric_algebra/#Introductory-resources","page":"Geometric Algebra","title":"Introductory resources","text":"","category":"section"},{"location":"explanation/geometric_algebra/","page":"Geometric Algebra","title":"Geometric Algebra","text":"Very approachable introduction by Eric Chisolm (paper)\nSiggraph 2019 talk (video)\nCambridge course\nIntroductory book: Vince, J. (2008). Geometric algebra for computer graphics. Springer Science & Business Media.","category":"page"},{"location":"explanation/geometric_algebra/#Reference-resources","page":"Geometric Algebra","title":"Reference resources","text":"","category":"section"},{"location":"explanation/geometric_algebra/","page":"Geometric Algebra","title":"Geometric Algebra","text":"bivector.net\nprojectivegeometricalgebra.org\nProjective geometric algebra (PGA):\nPGA wiki (E. Lengyel)\n3D PGA poster (E. Lengyel)\nConformal geometric algebra (CGA):\nCGA wiki (E. Lengyel)\n3D CGA poster (E. Lengyel)","category":"page"},{"location":"explanation/geometric_algebra/#Geometric-Calculus","page":"Geometric Algebra","title":"Geometric Calculus","text":"","category":"section"},{"location":"explanation/geometric_algebra/","page":"Geometric Algebra","title":"Geometric Algebra","text":"Note: this topic is more advanced.","category":"page"},{"location":"explanation/geometric_algebra/","page":"Geometric Algebra","title":"Geometric Algebra","text":"Reference book (also a great reference book outside geometric calculus): Hestenes, D., & Sobczyk, G. (2012). Clifford algebra to geometric calculus: a unified language for mathematics and physics (Vol. 5). Springer Science & Business Media.\nAdvanced tutorial (video)\nCompact summary (advanced): Macdonald, A. (2017). A survey of geometric algebra and geometric calculus. Advances in Applied Clifford Algebras, 27(1), 853-891.","category":"page"},{"location":"reference/api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"reference/api/","page":"API","title":"API","text":"Main symbols:","category":"page"},{"location":"reference/api/","page":"API","title":"API","text":"@ga\n@geometric_space\nKVector\nBindings\ncodegen_expression\ndefault_bindings","category":"page"},{"location":"reference/api/","page":"API","title":"API","text":"Aliases:","category":"page"},{"location":"reference/api/","page":"API","title":"API","text":"Bivector\nTrivector\nQuadvector","category":"page"},{"location":"reference/api/#Usage","page":"API","title":"Usage","text":"","category":"section"},{"location":"reference/api/","page":"API","title":"API","text":"@ga\n@pga2\n@pga3\n@cga3\n@geometric_space\nKVector\nBivector\nTrivector\nQuadvector","category":"page"},{"location":"reference/api/#SymbolicGA.@ga","page":"API","title":"SymbolicGA.@ga","text":"@ga <sig> <T> <ex>\n@ga <sig> <ex>\n\nGenerate Julia code which implements the computation of geometric elements from ex in an algebra defined by a signature sig (see SymbolicGA.Signature).\n\nSupported syntax:\n\nsig: Integer literal or tuple of 1, 2 or 3 integer literals corresponding to the number of positive, negative and degenerate basis vectors respectively, where unspecified integers default to zero. May also be a string literal of the form <+++--𝟎> where the number of +, - and 𝟎 correspond to the nmuber of positive, negative and degenerate basis vectors respectively.\nT: Any arbitrary expression which evaluates to a type or to nothing.\nex: Any arbitrary expression that can be parsed algebraically.\n\nSee also: codegen_expression.\n\nex can be a single statement or a block, and uses a domain-specific language to facilitate the construction of algebraic expressions. ex is logically divided into two sections: a definition section, which defines bindings, and a final algebraic expression, which will be the object of the evaluation. It is processed in three phases:\n\nA definition phase, in which bindings are defined with one or several statements for use in the subsequent phase;\nAn expansion phase, where identified bindings in the final algebraic expression are expanded. The defined bindings include the ones priorly defined and a set of default bindings.\nAn evaluation phase, in which the core algebraic expression is simplified and translated into a Julia expression.\n\nExpression parsing\n\nBinding definitions\n\nAll statements prior to the last can define new variables or functions with the following syntax and semantics:\n\nVariables are either declared with <lhs::Symbol> = <rhs::Any> or with <lhs::Symbol>::<type>, the latter being expanded to <lhs> = <lhs>::<type>.\nFunctions are declared with a standard short or long form function definition <name>(<args...>) = <rhs> or function <name>(<args...>) <rhs> end, and are restricted to simple forms to encode simple semantics. The restrictions are as follows:\nwhere clauses and output type annotations are not supported.\nFunction arguments must be untyped, e.g. f(x, y) is allowed but not f(x::Vector, y::Vector).\nFunction arguments must not be reassigned; it is assumed that any occurence of symbols declared as arguments will reference these arguments. For example, f(x, y) = x + y assumes that x + y actually means \"perform + on the first and second function argument\". Therefore, f(x, y) = (x = 2; x) + y will be likely to cause bugs. To alleviate this restriction, use codegen_expression with a suitable [SymbolicGA.Bindings] with function entries that contain specific calls to `:($(@arg <i>)).\n\nBinding expansion\n\nReferences and functions are expanded in a fairly straightforward copy-paste manner, where references are replaced with their right-hand side and function calls with their bodies with their arguments interpolated. Simple checks are put in place to allow for self-referencing bindings for references, such as x = x::T, leading to a single expansion of such a pattern in the corresponding expression subtree.\n\nSee SymbolicGA.Bindings for more information regarding the expansion of such variables and functions.\n\nFunction calls will be assumed to be either referencing a binding or a built-in function. If you want to call a function, e.g. my_func(x)::Vector, you will have to interpolate the call: $(my_func(x))::Vector.\n\nAlgebraic evaluation\n\nType annotations may either:\n\nSpecify what type of geometric entity an input should be considered as, where components are then picked off with getcomponent.\nRequest the projection of an intermediate expression over one or multiple grades.\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#SymbolicGA.@pga2","page":"API","title":"SymbolicGA.@pga2","text":"@pga2(T, ex)\n@pga2(ex)\n\nMacro generated via SymbolicGA.@geometric_space with signature (2, 0, 1)  and the following definitions:\n\nembed(x) = x[1]::e1 + x[2]::e2\nmagnitude2(x) = x ⦿ x\npoint(x) = embed(x) + 1.0::e3\n\nNo documentation found.\n\nSymbolicGA.@pga2 is a macro.\n\n# 2 methods for macro \"@pga2\" from SymbolicGA:\n [1] var\"@pga2\"(__source__::LineNumberNode, __module__::Module, ex)\n     @ ~/work/SymbolicGA.jl/SymbolicGA.jl/src/spaces.jl:61\n [2] var\"@pga2\"(__source__::LineNumberNode, __module__::Module, T, ex)\n     @ ~/work/SymbolicGA.jl/SymbolicGA.jl/src/spaces.jl:57\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#SymbolicGA.@pga3","page":"API","title":"SymbolicGA.@pga3","text":"@pga3(T, ex)\n@pga3(ex)\n\nMacro generated via SymbolicGA.@geometric_space with signature (3, 0, 1)  and the following definitions:\n\nembed(x) = x[1]::e1 + x[2]::e2 + x[3]::e3\nmagnitude2(x) = x ⦿ x\npoint(x) = embed(x) + 1.0::e4\n\nNo documentation found.\n\nSymbolicGA.@pga3 is a macro.\n\n# 2 methods for macro \"@pga3\" from SymbolicGA:\n [1] var\"@pga3\"(__source__::LineNumberNode, __module__::Module, ex)\n     @ ~/work/SymbolicGA.jl/SymbolicGA.jl/src/spaces.jl:61\n [2] var\"@pga3\"(__source__::LineNumberNode, __module__::Module, T, ex)\n     @ ~/work/SymbolicGA.jl/SymbolicGA.jl/src/spaces.jl:57\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#SymbolicGA.@cga3","page":"API","title":"SymbolicGA.@cga3","text":"@cga3(T, ex)\n@cga3(ex)\n\nMacro generated via SymbolicGA.@geometric_space with signature (4, 1)  and the following definitions:\n\nembed(x) = x[1]::e1 + x[2]::e2 + x[3]::e3\nmagnitude2(x) = x ⦿ x\npoint(x) = (embed(x) + (0.5::Scalar ⟑ magnitude2(embed(x))) ⟑ n + n̄)::Vector\nweight(X) = -X ⋅ n\nunitize(X) = X / weight(X)\nradius2(X) = (magnitude2(X) / magnitude2(X ∧ n))::Scalar\ncenter(X) = (X ⟑ n) ⟑ X\ndistance(S, X) = unitize(S) ⋅ unitize(X)\n\n3D Conformal Geometric Algebra.\n\nwarning: Warning\nThis functionality is experimental and will likely be subject to change in the future. It is not recommended for use beyond prototyping and playing around.\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#SymbolicGA.@geometric_space","page":"API","title":"SymbolicGA.@geometric_space","text":"@geometric_space name sig quote\n  n = 1.0::e4 + 1.0::e5\n  n̄ = (-0.5)::e4 + 0.5::e5\n  ... # other definitions\nend [warn_override = true]\n\nGenerate a macro @name which defines a geometric space with signature sig along with optional user-provided definitions.\n\nThe resulting macro will have two methods:\n\n@name ex, which acts as a standard @ga sig ex (but with potential extra definitions).\n@name T ex which wraps the result into type T, just like @ga sig T ex would (see @ga).\n\nIf definitions are provided as an Expr, they will be parsed into Bindings and added to the default bindings. If definitions already are Bindings, they will be used as is. warn_override can be set to false if you purposefully intend to purposefully override some of the default bindings.\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#SymbolicGA.KVector","page":"API","title":"SymbolicGA.KVector","text":"KVector{K,T,D,N}\n\nGeometric K-vector with eltype T with N elements in a geometric algebra of dimension D.\n\nThe constructors KVector{K,D}(elements...) and KVector{K,D}(elements::NTuple) will automatically infer T from the arguments and N from K and D.\n\nExamples\n\njulia> KVector{1,3}(1.0, 2.0, 3.0)\nKVector{1, Float64, 3, 3}(1.0, 2.0, 3.0)\n\njulia> KVector{2,3}(1.0, 2.0, 3.0)\nBivector{Float64, 3, 3}(1.0, 2.0, 3.0)\n\njulia> KVector{4,4}(1.0)\nQuadvector{Float64, 4, 1}(1.0)\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#SymbolicGA.Bivector","page":"API","title":"SymbolicGA.Bivector","text":"Bivector{T,D,N}\n\nAlias for KVector{2,T,D,N}\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#SymbolicGA.Trivector","page":"API","title":"SymbolicGA.Trivector","text":"Trivector{T,D,N}\n\nAlias for KVector{3,T,D,N}\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#SymbolicGA.Quadvector","page":"API","title":"SymbolicGA.Quadvector","text":"Quadvector{T,D,N}\n\nAlias for KVector{4,T,D,N}\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Expression-generation","page":"API","title":"Expression generation","text":"","category":"section"},{"location":"reference/api/","page":"API","title":"API","text":"codegen_expression\nBindings\ndefault_bindings\nSymbolicGA.Signature\nSymbolicGA.@arg","category":"page"},{"location":"reference/api/#SymbolicGA.codegen_expression","page":"API","title":"SymbolicGA.codegen_expression","text":"codegen_expression(sig, ex; T = nothing, bindings::Optional{Bindings} = nothing)\n\nParse ex as an algebraic expression and generate a Julia expression which represents the corresponding computation. sig can be a SymbolicGA.Signature, a signature integer or a signature string, tuple or tuple expression adhering to semantics of @ga. See @ga for more information regarding the parsing and semantics applied to ex.\n\nParameters\n\nT specifies what type to use when reconstructing geometric entities from tuple components with construct. If set to nothing and the result is in a non-flattened form (i.e. not annotated with an annotation of the type <ex>::(0 + 2)), then an appropriate KVector will be used depending on which type of geometric entity is returned; if multiple entities are present, a tuple of KVectors will be returned. If the result is in a flattened form, T will be set to :Tuple if unspecified.\nbindings is a user-provided SymbolicGA.Bindings which controls what expansions are carried out on the raw Julia expression before conversion to an algebraic expression.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#SymbolicGA.Bindings","page":"API","title":"SymbolicGA.Bindings","text":"Bindings(; refs = Dict{Symbol,Any}(), funcs = Dict{Symbol,Any}(), warn_override = true)\n\nStructure holding information about bindings which either act as references (simple substitutions) or as functions, which can be called with arguments. This allows a small domain-specific language to be used when constructing algebraic expressions.\n\nReferences are lhs::Symbol => rhs pairs where the left-hand side simply expands to the right-hand side during parsing. Right-hand sides which include lhs are supported, such that references of the form x = x::Vector are allowed, but will be expanded only once. Functions are name::Symbol => body pairs where rhs must refer to their arguments with Expr(:argument, <literal::Int>) expressions. Recursion is not supported and will lead to a StackOverflowError. See @arg.\n\nMost default functions and symbols are implemented using this mechanism. If warn_override is set to true, overrides of such default functions will trigger a warning.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#SymbolicGA.default_bindings","page":"API","title":"SymbolicGA.default_bindings","text":"Bindings included by default in @ga.\n\nBy default, any user-defined symbol overriding a symbol defined here will trigger a warning; set warn_override = false to disable this.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#SymbolicGA.Signature","page":"API","title":"SymbolicGA.Signature","text":"Signature(positive::Int, negative::Int = 0, degenerate::Int = 0)\nSignature(str::AbstractString) # Signature(\"++-𝟎\")\n\nSignature of an Euclidean or pseudo-Euclidean space.\n\nThis signature encodes a space with a metric such that the first P basis vectors square to 1, the following N to -1 and the following D to 0. The metric evaluates to zero between two distinct basis vectors.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#SymbolicGA.@arg","page":"API","title":"SymbolicGA.@arg","text":"@arg <literal::Integer>\n\nConvenience macro to construct expressions of the form Expr(:argument, i) used within function definitions for SymbolicGA.Bindings.\n\n\n\n\n\n","category":"macro"},{"location":"reference/api/#Interface-methods","page":"API","title":"Interface methods","text":"","category":"section"},{"location":"reference/api/","page":"API","title":"API","text":"SymbolicGA.getcomponent\nSymbolicGA.construct","category":"page"},{"location":"reference/api/#SymbolicGA.getcomponent","page":"API","title":"SymbolicGA.getcomponent","text":"getcomponent(collection)\ngetcomponent(collection, i)\ngetcomponent(collection, j, i)\n\nRetrieve a number from a collection to be interpreted as the component of a geometric entity.\n\ngetcomponent(collection) which defaults to collection[] is used to extract the only component of a scalar or antiscalar.\n\ngetcomponent(collection, j, i) which defaults to collection[j][i] is used to extract the i-th component the j-th geometric entity for a collection of multiple geometric vectors.\n\ngetcomponent(collection, i) which defaults to collection[i] is used to extract the i-th component of a single geometric entity or a set of geometric entities backed by collection. In the case of a set of geometric entities, this is semantically equivalent to getcomponent(collection, j, i) where a single i is computed from the cumulated sum of past indices, i.e. as if components from consecutive entities were concatenated together. See @ga for more information regarding which mode is used depending on the syntax for grade extraction.\n\nMost collections will not need to extend this method, but is exposed should the need arise for a tigher control over how input data is accessed.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#SymbolicGA.construct","page":"API","title":"SymbolicGA.construct","text":"construct(T, components::Tuple)\n\nConstruct an instance of T from a tuple of components.\n\nDefaults to T(components).\n\n\n\n\n\n","category":"function"},{"location":"#SymbolicGA.jl","page":"Home","title":"SymbolicGA.jl","text":"","category":"section"},{"location":"#Status","page":"Home","title":"Status","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is ready for general use, but it still in active development and bugs may be frequently encountered along with incomplete or unsupported major features. You are welcome to report potential issues or to suggest improvements. When upgrading to a new major version, make sure to consult the changelog to be aware of any major breakages.","category":"page"},{"location":"explanation/design/#Design-choices","page":"Design","title":"Design choices","text":"","category":"section"},{"location":"explanation/design/","page":"Design","title":"Design","text":"There are many ways to implement geometric algebra numerically, and each performs its own trade-offs, depending on the goals it is set to achieve.","category":"page"},{"location":"explanation/design/","page":"Design","title":"Design","text":"In this library, we seek to allow the use of geometric algebra as a language to express logic. In particular, having a concrete representation of the objects and operators of geometric algebra is not a necessity, as long as the relevant operations are easy to express. This is relevant in context of the integration with existing codebases; we chose not to require the use of library-specific types nor, for most cases, to extend specific methods. The interface with this library is based around the way data is to be cast into the semantics of geometric algebra. This should not affect the data structures you choose; be it a tuple, vector or static array, we only need a way to map data to components (see this how-to).","category":"page"},{"location":"explanation/design/","page":"Design","title":"Design","text":"Having direct control over the code that is generated was also one motivation for operating at the symbolic level. It is more work to implement a library which has to manipulate symbolic expressions, but we believe that the benefits are largely worth the effort. The performance guaranteed by processing and optimizing algebraic operations at macro expansion time (i.e. right after parsing, before compilation) furthermore allowed us to escape the limitation of supporting a fixed set of signatures, empowering the user to use whatever space they see fit. In a sense, SymbolicGA.jl can be considered a just-in-time library generator, combining the performance of such generators with the flexibility of other, more dynamic approaches.","category":"page"},{"location":"explanation/design/","page":"Design","title":"Design","text":"Another advantage of operating at the symbolic level is that the way syntax is interpreted can also be controlled. We could implement a fairly simple binding-based substitution with references (which expand to an expression) and basic functions (expanding to an expression, but inserting one argument or more), which prevented us from needing to commit to specific function names and aliases to be exported. This flexibility of notation is particularly relevant in the context of geometric algebra as certain operators or variables may have different notations. Examples include the geometric product, most often noted * but sometimes noted ⟑ or the pseudoscalar most often noted I but sometimes noted 𝟙 (see the motivations for the latter notations).","category":"page"}]
}
